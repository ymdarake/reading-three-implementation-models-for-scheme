## 3.3 Implementation Strategy
- The one given here is intended to be simple to understand and to generalize easily to the systems of the following chapter.
    - It does not exactly model any used by the implementations mentioned at the start of this chapter.
- **An iterative approach is necessary** because the more straightforward recursive approach of the meta-circular interpreter presented in Chapter 2 cannot properly **support continuations or tail calls**.
    - The evaluator must have **explicit access to the state of the computation** in order to save this state in a continuation, and recursion makes some of this state implicit;
        - this state is on the meta level and not available directly to the implementation.
        - Tail calls cannot be properly supported unless the implementation (at the meta level) supports them properly.
- The strategies of this chapter use five registers:
  - ***a: the accumulator***
    - **holds the last value computed by a value-returning operation such as loading a constant or referencing a variable**.
        - During function application it holds the value of each of the arguments in turn before they are saved on the value rib, and the function value before it is applied.
        - During the evaluation of an if expression it holds the value of the test expression; if uses it to determine which of the two other subexpressions to evaluate.
        - The value of the accumulator when a computation finishes is the value of the computation.
  - ***x: the next expression***
    - **specifies the next expression to evaluate**, such as the loading of a constant, the creation of a closure, the assignment of a closure, or the application of a closure.
    - The expression is almost the same as a Scheme source expression, except that it has been compiled to make the evaluation more efficient.
  - ***e: the current environment***
    - **holds the active lexical bindings**
        - A new environment is established upon application of a closure from **the closure’s saved environment** and **the arguments to the closure**
        - Variable references, variable assignments, and lambda expressions, i.e., creation of closures, use the current environment.
        - **Because the environment is destroyed by function application, the environment is saved in a call frame before the application takes place and restored upon return from the application**. 
  - ***r: the current value rib***
    - During evaluation of an application, the current value rib holds a **list of arguments evaluated so far**.
        - As with any expression, **when the computation of an argument expression completes, its value is in the accumulator. This value is added to the current rib using cons**.
        - Once all of the argument values and the closure value have been computed, **the current rib combines with the closure’s environment to produce the new current environment**.
        - Because the current rib is destroyed by the evaluation of an application, it is saved along with the environment in the call frame before the application takes place.
  - ***s: the current stack***
    - **holds the top call frame.**
        - Call frames are added to the stack before the start of an application, and removed upon return from a closure.
        - As noted earlier, a call frame consists of
            - a saved environment
            - a saved value rib
            - a saved expression that corresponds to a return address
            - a link to the previous call frame
        - **When a call frame is removed from the current stack, these saved values are restored to the current environment, current rib, and next expression registers**.
        - **The current stack itself may be saved at any time in a continuation object by the evaluation of a** ***call/cc*** **expression**.

### The evaluation strategies for constants, variables, applications, and the core syntactic forms in terms of how they affect the registers is given in the paragraphs below.

